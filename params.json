{"name":"Spineless","tagline":"Small and simple DOM front-end library.","body":"# Spineless\r\n\r\nThis project is my ideal front-end JavaScript library (like Backbone or Spine) but with a much looser paradigm.\r\n\r\n## Spineless.View\r\n\r\nEvery object in Spineless is a `View`. It contains some data (or a Model) and a DOM template. This template is converted to DOM nodes and appended to a DocumentFragment.\r\n\r\n### **extend** `Spineless.View.extend(properties)`\r\nCreate a custom view by providing instance properties.\r\n\r\nSetups up the prototype chain so you may can continue subclassing.\r\n\r\n~~~javascript\r\nvar Button = Spineless.View.extend({\r\n\tinit: function () { ... },\r\n\tonclick: function () { ... }\r\n});\r\n\r\nvar DisabledButton = Button.extend({\r\n\tonclick: function () {\r\n\t\treturn false;\r\n\t}\r\n});\r\n~~~\r\n\r\n### **super** `Spineless.View.super(context, method, arguments)` *alias: Constructor*\r\nExecute a method on the parent class. Pass the instance, the method name\r\nand an array of arguments to apply to the method. A simple\r\ntrick is to use the [`arguments`](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/arguments) object native to JavaScript functions.\r\n\r\n~~~javascript\r\nvar Button = Spineless.View.extend({\r\n\tinit: function () {\r\n\t\t//execute `init` on the View class\r\n\t\t//with the same arguments passed into\r\n\t\t//this constructor\r\n\t\tButton.super(this, \"init\", arguments);\r\n\t}\r\n});\r\n~~~\r\n\r\nA shortcut is to invoke the constructor as a function. This is an\r\nalias to `super`.\r\n\r\n~~~javascript\r\nvar Button = Spineless.View.extend({\r\n\tinit: function () {\r\n\t\t//execute `init` on the View class\r\n\t\t//with the same arguments passed into\r\n\t\t//this constructor\r\n\t\tButton(this, \"init\", arguments);\r\n\t}\r\n});\r\n~~~\r\n\r\n### **el** `view.el`\r\nEvery view has a reference to a DOM element (whether inserted to the page or not). \r\nWhen using a JSON template this is a [DocumentFragment](https://developer.mozilla.org/en-US/docs/DOM/document.createDocumentFragment). It can be inserted just like\r\nany other DOM node (such as [`appendChild`](https://developer.mozilla.org/en-US/docs/DOM/Node.appendChild)). If the template refers to an existing node,\r\nthis will be a reference to that node.\r\n\r\n~~~javascript\r\nvar button = new Button();\r\ndocument.body.appendChild(button.el);\r\n~~~\r\n\r\n### **template** `view.template`\r\nThe heart of Views are templates represented as JSON and converted\r\nto a DOM tree. It accepts an array of objects where the object\r\nrepresents the node to create.\r\n\r\n~~~javascript\r\nvar Button = Spineless.View.extend({\r\n\ttemplate: [\r\n\t\t{tag: \"a\", className: \"button\", children: [\r\n\t\t\t{tag: \"img\", id: \"icon\"},\r\n\t\t\t{tag: \"span\", id: \"label\"}\r\n\t\t]}\r\n\t]\r\n});\r\n~~~\r\n\r\nThe following is a list of special properties. Everything else is\r\ntreated as attribute on the node.\r\n\r\n- **tag -** HTML tag to create (e.g. `'a'`, `'span'`, `'input'`). Default `div`.\r\n- **children -** array of child nodes to create.\r\n- **className -** the class attribute. Generally styling.\r\n- **text -** will set the [`innerText`](https://developer.mozilla.org/en/docs/DOM/Node.textContent) of the node to this string value.\r\n- **view -** use a `Spineless.View` instead of creating a DOM node. Every other property on the object will be passed into the view constructor.\r\n- **id -** will allow the node to be referenced through an instance property.\r\n\r\nThere may be situations where the template already exists in the HTML page. You\r\ncan point the template to the parent node by passing its `ID` attribute\r\nas a string.\r\n\r\n~~~html\r\n<a id=\"existingButton\">\r\n\t<img name=\"icon\" />\r\n\t<span name=\"label\"></span>\r\n</a>\r\n~~~\r\n\r\n~~~javascript\r\nvar Button = Spineless.View.extend({\r\n\ttemplate: \"existingButton\",\r\n\trender: function () {\r\n\t\tthis.icon.style.display = \"none\";\r\n\t\tthis.label.innerText = \"Hello\";\r\n\t}\r\n});\r\n~~~\r\n\r\nAny child nodes with an `id` or `name` attribute will become instance properties.\r\n\r\n### **events** `view.events`\r\nShorthand way of assigning instance methods to an event callback \r\nin the template tree.\r\n\r\n~~~javascript\r\nvar Button = Spineless.View.extend({\r\n\tevents: {\r\n\t\t\"click el\": \"onclick\"\r\n\t},\r\n\r\n\tonclick: function (evt) { ... }\r\n});\r\n~~~\r\n\r\nThe key is a notation to define first the event then the element in the\r\ntemplate by `id` (seperated by a space). The value is a string representing \r\nthe method name in the class to trigger.\r\n\r\n### **defaults** `view.defaults`\r\nUse this object to define the properties for the `model` object of a view and\r\ntheir default values.\r\n\r\n~~~javascript\r\nvar Button = Spineless.View.extend({\r\n\tdefaults: {\r\n\t\ticon: \"/images/defaultIcon.png\",\r\n\t\tlabel: \"Button\"\r\n\t}\r\n});\r\n~~~\r\n\r\n### **model** `view.model`\r\nThis is the only seperation of concerns in the library. It is how\r\nyou access the instance model data. The values will be used to\r\nserialize the view as well as send its data to the server.\r\n\r\nIf an input node in the template has an `id` (or `name`) attribute with \r\nthe same name as a model property, the value will automatically be bound.\r\n\r\n~~~javascript\r\nvar Login = Spineless.View.extend({\r\n\tdefaults: {\r\n\t\tusername: \"\",\r\n\t\tpassword: \"\"\r\n\t},\r\n\r\n\tevents: {\r\n\t\t\"click submit\": \"onsubmit\"\r\n\t},\r\n\r\n\ttemplate: [\r\n\t\t{tag: \"input\", id: \"username\", type: \"text\"},\r\n\t\t{tag: \"input\", id: \"password\", type: \"password\"},\r\n\t\t{tag: \"button\", id: \"submit\", text: \"Go!\"}\r\n\t],\r\n\r\n\tonsubmit: function () {\r\n\t\tconsole.log(this.model.username, this.model.password);\r\n\t}\r\n});\r\n~~~\r\n\r\n*Note: An input node is an HTML element typically used in forms. This\r\nincludes `<input>`, `<select>`, `<button>`, `<textarea>`.*\r\n\r\n### **render** `view.render()`\r\nThis method will be executed after the class has been instantiated\r\nand on any `Change` events. You should put all code to modify the DOM\r\nin this method.\r\n\r\n~~~javascript\r\nvar UriEncoder = Spineless.View.extend({\r\n\tdefaults: {\r\n\t\tinput: \"\"\r\n\t},\r\n\r\n\ttemplate: [\r\n\t\t{tag: \"input\", id: \"input\"},\r\n\t\t{tag: \"span\", id: \"result\"}\r\n\t],\r\n\r\n\trender: function () {\r\n\t\tthis.result.innerText = encodeURIComponent(this.model.input);\r\n\t}\r\n});\r\n~~~\r\n\r\n## Spineless.Event\r\n\r\nAt the root of every class is `Spineless.Event`. It manages emitting and\r\nlistening to events throughout the instance. The methods here should be very\r\nfamiliar as the API is the same as [Backbone.js](http://documentcloud.github.com/backbone/#Events) and [Node.js](http://nodejs.org/api/events.html).\r\n\r\n### **on** `event.on(eventName, callback)` *alias: bind, subscribe*\r\nBind a callback function to an event name. Colons are used\r\nas a convention to namespace event types (e.g. `change:textbox`). \r\n\r\n*Note: This will only work with one level of namespacing.*\r\n\r\nAn asterisk `*` can be used as a wildcard to listen to all\r\nevents in a namespace.\r\n\r\n~~~javascript\r\n//listen to all change events\r\nthis.on(\"change:*\", function () { ... });\r\n//listen to a specific change event\r\nthis.on(\"change:textbox\", function () { ... });\r\n~~~\r\n\r\nTo bind multiple events to a single callback, specify multiple\r\nevent names delimeted by a space.\r\n\r\n~~~javascript\r\nthis.on(\"change:textbox change:checkbox\", ... );\r\n~~~\r\n\r\nAn object can instead be passed to map event names to callback functions.\r\n\r\n~~~javascript\r\nthis.on({\r\n\t\"change:textbox change:checkbox\": this.update,\r\n\t\"dom:click\": this.submit\r\n});\r\n~~~\r\n\r\n### **off** `event.off(eventName, callback)` *alias: unbind, unsubscribe*\r\nRemove a bound callback from an event name. If no callback is specified,\r\nall events with that name will be remove. If neither callback or event name\r\nis specified, every event will be removed.\r\n\r\n~~~javascript\r\n//remove a specific callback on `change`\r\nthis.off(\"change\", this.onChange);\r\n\r\n//remove every callback on `change`\r\nthis.off(\"change\");\r\n\r\n//remove every event handler\r\nthis.off();\r\n~~~\r\n\r\n### **emit** `event.emit(eventName[, args*])` *alias: trigger, publish`*\r\nExecute callbacks that are bound to this event name. Every subsequent argument\r\nwill be passed into the callback function as arguments.\r\n\r\n~~~javascript\r\n//listen for the `ping` event\r\nthis.on(\"ping\", function (message) {\r\n\talert(\"Pong \" + message);\r\n});\r\n\r\n//trigger the `ping` handler and pass in\r\n//the string \"dong\" as an argument.\r\nthis.emit(\"ping\", \"dong\");\r\n~~~\r\n\r\n### **once** `event.once(eventName, callback)`\r\nBind to an event for one use only and then remove the callback.\r\n\r\n### Internal Events\r\n\r\n- `change (key, value)` after a bound input node changes its value.\r\n- `change:key (value)` after a specific input node changes its value.\r\n- `prechange (key, value)` before a bound input node changes its value.\r\n- `prechange:key (value)` before a specific input node changes its value.\r\n- `dom:event (DOMEvent)` when a [DOM event](https://developer.mozilla.org/en-US/docs/DOM/event) has been created through `events` object.\r\n- `child:add (child)` when a child view has been added to `this`.\r\n- `child:remove (child)` when a child view has been removed from `this`.\r\n- `parent:add (parent)` when a parent view has been added to `this`.\r\n- `parent:remove (parent)` when a parent view has been removed from `this`.\r\n- `invalid (errorString)` when `validation()` returns an error.\r\n- `error (errorObject)` when an error occurs in `sync()`.\r\n\r\n## Examples\r\n\r\nThe following example will create a Button view class.\r\n\r\n~~~javascript\r\nvar CustomButton = Spineless.View.extend({\r\n\t//define the default properties for this class\r\n\t//will be accessible through `this.model`.\r\n\tdefaults: {\r\n\t\ticon: \"\",\r\n\t\tlabel: \"\"\r\n\t},\r\n\r\n\t//define your HTML template in JSON\r\n\ttemplate: [\r\n\t\t{tag: \"a\", children: [\r\n\t\t\t//assigning an ID attribute will make the node\r\n\t\t\t//accessible within this class\r\n\t\t\t{tag: \"img\", id: \"icon\"},\r\n\t\t\t{tag: \"span\", id: \"label\"}\r\n\t\t]}\r\n\t],\r\n\r\n\trender: function () {\r\n\t\t//these refer to the nodes we created in the template above\r\n\t\tthis.icon.src = this.model.icon;\r\n\t\tthis.label.innerText = this.model.label;\r\n\t}\r\n});\r\n\r\n//properties passed into the constructor that are\r\n//part of the model will automatically be copied\r\nvar myButton = new CustomButton({\r\n\ticon: \"/path/to/icon.png\",\r\n\tlabel: \"My Button\"\r\n});\r\n~~~\r\n\r\nThe `myButton` instance won't actually add anything to the\r\npage as all the DOM nodes created are applied to a DocumentFragment. We\r\nmust append the fragment to the webpage DOM tree. This is available through\r\n`myButton.el`.\r\n\r\n~~~javascript\r\ndocument.getElementById(\"navigation\").appendChild(myButton.el);\r\n~~~\r\n\r\n## Legacy Browser Support\r\nSpineless makes use of a few modern JavaScript APIs. If you need to support\r\nolder browsers you may need to shim these APIs.\r\n\r\n- `JSON.stringify()` - Used to serialize a View. Recommended shim: [json2](https://github.com/douglascrockford/JSON-js)\r\n- `Function.bind()` - This is a quick way to modify the context of a function. Recommended shim: [MDN](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind#Compatibility) or [ES5-shim](https://github.com/kriskowal/es5-shim)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}